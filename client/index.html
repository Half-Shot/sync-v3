<html>
    <head>
        <title>Sync v3 experiments</title>
        <script>
            let activeSessionId;
            // rooms array is stored as a map since we just keep indices. E.g 0-99, 500-599, we don't want to have a 600 element array
            let allRooms = {};
            let allRoomsCount = 0;
            const roomIdToRoom = {};
            const roomIdToDiv = {}; // cached innerHTML 
            const render = (container) => {
                // TODO: don't nuke all cells
                while (container.firstChild) {
                    container.removeChild(container.firstChild);
                }
                for (let i = 0; i < allRoomsCount; i++) {
                    const template = document.getElementById("roomCellTemplate");
                    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template#avoiding_documentfragment_pitfall
                    const roomCell = template.content.firstElementChild.cloneNode(true);

                    const r = allRooms[i];
                    if (!r) {
                        // placeholder
                        roomCell.getElementsByClassName("roomInfo")[0].style = "filter: blur(5px);";
                        container.appendChild(roomCell);
                        continue;
                    }
                    roomIdToRoom[r.room_id] = r;
                    
                    roomCell.addEventListener("click", (e) => {
                        console.log(r, e);
                    });
                    roomIdToDiv[r.room_id] = roomCell;
                    roomCell.getElementsByClassName("roomName")[0].textContent = r.name || r.room_id;
                    if (r.timeline && r.timeline.length > 0) {
                        const mostRecentEvent = r.timeline[r.timeline.length-1];
                        roomCell.getElementsByClassName("roomSender")[0].textContent = mostRecentEvent.sender;

                        if (mostRecentEvent.type === "m.room.message") {
                            roomCell.getElementsByClassName("roomContent")[0].textContent = mostRecentEvent.content.body;
                        } else if (mostRecentEvent.type) {
                            roomCell.getElementsByClassName("roomContent")[0].textContent = mostRecentEvent.type + " event";
                        }
                    }
                    container.appendChild(roomCell);
                }


            }

            const doSyncLoop = async(accessToken, sessionId) => {
                console.log("Starting sync loop. Active: ", activeSessionId, " this:", sessionId);
                let currentPos;
                while (sessionId === activeSessionId) {
                    let resp = await doSyncRequest(accessToken, currentPos, [0,99], sessionId);
                    currentPos = resp.pos;
                    if (!resp.ops) {
                        continue;
                    }
                    if (resp.count) {
                        allRoomsCount = resp.count;
                    }

                    let gapIndex = -1;
                    resp.ops.forEach((op) => {
                        if (op.op === "DELETE") {
                            delete allRooms[op.index];
                            gapIndex = op.index;
                        } else if (op.op === "INSERT") {
                            if (allRooms[op.index]) {
                                // something is in this space, shift items out of the way
                                if (gapIndex < 0) {
                                    console.log("cannot work out where gap is, INSERT without previous DELETE!");
                                    return;
                                }
                                //  0,1,2,3  index
                                // [A,B,C,D]
                                //   DEL 3
                                // [A,B,C,_]
                                //   INSERT E 0
                                // [E,A,B,C]
                                // gapIndex=3, op.index=0
                                if (gapIndex > op.index) {
                                    // the gap is further down the list, shift every element to the right
                                    // starting at the gap so we can just shift each element in turn
                                    // [A,B,C,C] i=3
                                    // [A,B,B,C] i=2
                                    // [A,A,B,C] i=1
                                    // Terminate. We'll assign into op.index next.
                                    for (let i = gapIndex; i > op.index; i--) {
                                        allRooms[i] = allRooms[i-1];
                                    }
                                } else if (gapIndex < op.index) {
                                    // the gap is further up the list, shift every element to the left
                                    // starting at the gap so we can just shift each element in turn
                                    for (let i = gapIndex; i < op.index; i++) {
                                        allRooms[i] = allRooms[i+1];
                                    }
                                }
                            }
                            allRooms[op.index] = op.room;
                        } else if (op.op === "UPDATE") {
                            allRooms[op.index] = op.room;
                        } else if (op.op === "SYNC") {
                            const startIndex = op.range[0];
                            for (let i = startIndex; i <= op.range[1]; i++) {
                                allRooms[i] = op.rooms[i - startIndex];
                            }
                        }
                    });
                    render(document.getElementById("listContainer"));
                }
                console.log("active session: ", activeSessionId, " this session: ", sessionId, " terminating.");
            }
            // accessToken = string, pos = int, ranges = [2]int e.g [0,99]
            const doSyncRequest = async (accessToken, pos, ranges, sessionId) => {
                let resp = await fetch("/_matrix/client/v3/sync" + (pos ? "?pos=" + pos : ""), {
                    method: "POST",
                    headers: {
                        "Authorization": "Bearer " + accessToken,
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify({
                        rooms: [ranges],
                        session_id: (sessionId ? sessionId : undefined),
                    })
                });
                let respBody = await resp.json();
                console.log(respBody);
                return respBody;
            }

            window.addEventListener('load', (event) => {
                const storedAccessToken = window.localStorage.getItem("accessToken");
                if (storedAccessToken) {
                    document.getElementById("accessToken").value = storedAccessToken;
                }
                document.getElementById("syncButton").onclick = () => {
                    const accessToken = document.getElementById("accessToken").value;
                    window.localStorage.setItem("accessToken", accessToken);
                    doSyncLoop(accessToken, activeSessionId);
                }
                document.getElementById("resetButton").onclick = () => {
                    activeSessionId = new Date().getTime() + "";
                }
            });
        </script>
    </head>
    <body>
        <div style="max-width: 960px; margin: 0 auto">
            <input id="accessToken" type="password" placeholder="matrix.org access token" />
            <input id="syncButton" type="button" value="Sync" />
            <input id="resetButton" type="button" value="New Session" />
            <div id="listContainer" style="background: #f7f7f7;" ></div>
            <template id="roomCellTemplate">
                <div style="padding: 5px; display: flex; align-items: center; cursor: pointer; border-bottom: 1px solid #8d99a5; height: 40px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                    <img src="/client/placeholder.svg" style="width: 32px; height: 32px; margin-right: 6px;"/>
                    <div class="roomInfo">
                        <span class="roomName">Placeholder Room Name</span>
                        <div>
                            <span class="roomSender" style="color: #737d8c;">Alice</span>
                            <span class="roomContent">Lorem Ipsum Dolor...</span>
                        </div>
                    </div>
                </div>
            </template>
        </div>
    </body>
</html>